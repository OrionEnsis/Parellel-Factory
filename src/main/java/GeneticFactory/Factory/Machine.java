package GeneticFactory.Factory;

import javax.annotation.Nonnull;

/**
 * this class manages the properties of a single machine used in the factory genetic algorithm.
 */
public class Machine implements Comparable<Machine> {

    Tiles name;
    int x, y;
    private int preProduct;
    private int maxFlow;
    private int product;
    private Tiles inputMachine;
    private Tiles outputMachine;

    /**
     * the base constructor that records the coordinates of the variables and the default tile.
     * @param x the x coordinate
     * @param y the y coordinate
     * @param name the Tile
     */
    public Machine(int x, int y, Tiles name){
        this.name = name;
        this.x = x;
        this.y = y;
        getInputMachine();
        getOutputMachine();
        determineMaxFlow();
    }

    /**
     * this produces a copy of a Machine.  it suppresses a CopyConstructorMissesField warning.  the remaining field is
     * generated by recursive constructor call.
     * @param m the Machine being copied.
     */
    @SuppressWarnings("CopyConstructorMissesField")
    public Machine(Machine m){
        this(m.x,m.y,m.getName());
    }

    /**
     * resets a machine for the next simulation tick
     */
    void resetMachine(){
        preProduct = 0;
        product = 0;
    }

    /**
     * determines what the product produced per tick is based on the tile of the Machine.
     */
    private void determineMaxFlow(){
        switch(name){
            case A:
                maxFlow = 64;
                break;
            case B:
                maxFlow = 48;
                break;
            case C:
                maxFlow = 48;
                break;
            case D:
                maxFlow = 32;
                break;
            case E:
                maxFlow = 64;
                break;
            case EMPTY:
                maxFlow = 0;
                break;
        }
    }

    /**
     * determines the Machine this Machine needs to produce product.
     */
    private void getInputMachine(){
        switch(name){
            case A:
                inputMachine = Tiles.EMPTY;
                break;
            case B:
                inputMachine =  Tiles.A;
                break;
            case C:
                inputMachine =  Tiles.B;
                break;
            case D:
                inputMachine =  Tiles.C;
                break;
            case E:
                inputMachine =  Tiles.D;
                break;
            case EMPTY:
                inputMachine = null;
                break;
        }
    }

    /**
     * this method attempts to retrieve preProduct from the given Machine.  If it cannot, nothing happens, if it can,
     * it removes product from the given Machine and adds it to product.
     * @param m the Machine that product will be removed from.
     */
    void getPreProductFromInputMachine(Machine m){
        //if they are the same machine...don't do anything.
        if(distance(m) == 0)
            return;
        //if it is the correct machine type.
        if (m.getName().equals(inputMachine)){
            int neededToMaxFlow = maxFlow - preProduct;
            int demand = neededToMaxFlow/distance(m);
            preProduct += m.getProduct(demand);
        }
    }

    /**
     * the exchanges preProduct into product
     */
    void makeProduct(){
        if(!getName().equals(Tiles.A))
            product = preProduct;
        else
            product = maxFlow;
    }

    /**\
     * determines the distance between the two machines.
     * @param m the other Machine
     * @return  the distance between two machines using manhattan distance.
     */
    private int distance(Machine m){
        return Math.abs(x -m.x + y - m.y);
    }

    /**
     * attempts to give product based on the demand.  if demand is higher it returns all the product it has.
     * @param demand the amount of product to return
     * @return the product amount returned.
     */
    int getProduct(int demand){
        if(product > demand){
            product-= demand;
            return demand;
        }
        else{
            int temp = product;
            product = 0;
            return temp;
        }
    }

    /**
     * determine the output Machine based on the this Machines name.
     */
    private void getOutputMachine(){
        switch(name){
            case A:
                outputMachine = Tiles.B;
                break;
            case B:
                outputMachine =  Tiles.C;
                break;
            case C:
                outputMachine =  Tiles.D;
                break;
            case D:
                outputMachine =  Tiles.E;
                break;
            case E:
                outputMachine =  Tiles.EMPTY;
                break;
            case EMPTY:
                outputMachine = null;
                break;
        }
    }

    /**
     * Comparison with another Machine
     * @param o other Machine
     * @return the comparison
     */
    @Override
    public int compareTo(@Nonnull Machine o) {
        return name.compareTo(o.getName());
    }

    /**
     * get the Tile Name
     * @return name
     */
    Tiles getName(){
        return name;
    }

    /**
     * set the specific tile
     * @param name the new Tile name
     */
    void setName(Tiles name) {
        this.name = name;
        getInputMachine();
        getOutputMachine();
    }

    /**
     * scores a machine based on the other machine using the machine type and distance.
     * @param other the other Machine to base the score on.
     * @return the score of the machine based on placement.
     */
    int scoreMachine(Machine other) {
        int distance = distance(other);
        if (distance != 0){
            if (other.getName().equals(inputMachine) || other.getName().equals(outputMachine)) {
                return 3 / distance;
            } else if (!getName().equals(Tiles.EMPTY)){
                return -1/distance;
            }
        }
        return 0;
    }

}
