package GeneticFactory.Gui;

import GeneticFactory.Factory.FactoryBuilder;
import GeneticFactory.Factory.Tiles;
import javafx.application.Platform;
import javafx.embed.swing.SwingFXUtils;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;

import javax.imageio.ImageIO;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * This class controls the actions generated by the GUI.
 */
public class Controller {
    @FXML
    private TextField lengthField;
    @FXML
    private TextField widthField;
    @FXML
    private TextField aField;
    @FXML
    private TextField bField;
    @FXML
    private TextField cField;
    @FXML
    private TextField dField;
    @FXML
    private TextField eField;
    @FXML
    private TextField generationField;
    @FXML
    private TextField exchangeField;
    @FXML
    private ImageView factoryLayout;
    @FXML
    private ImageView recent1;
    @FXML
    private ImageView recent2;
    @FXML
    private ImageView recent3;
    @FXML
    private Label scoreListed;
    @FXML
    private Label score1;
    @FXML
    private Label score2;
    @FXML
    private Label score3;
    @FXML
    private Button buildButton;
    @FXML
    private CheckBox continueButton;

    private int length;
    private int width;
    private HashMap<Tiles,Integer> machines;
    private int currentHighScore = Integer.MIN_VALUE;
    private static Controller instance;
    private int exchanges;
    private int generations;
    private int finishedFactories;

    /**
     *
     * This method begins building a factory based on the designated inputs.  it throws exceptions
     * based on improper input in the TextFields.  It will focus the first invalid field if input is
     * incorrect.
     */
    @FXML
    public void onBuildFactory(){
        instance = this;
        boolean success = true;
        currentHighScore = 0;
        scoreListed.setText("0");

        int sum = 0;
        final int MINIMUM_MACHINES = 32;
        final int MIN_DIMENSION = 8;
        machines = new HashMap<>();

        //make sure that no improper input occurs.  multiple tries to ensure only a single error message.
        try {
            length = parseField(lengthField,"The length must be at least " + MIN_DIMENSION + ".",MIN_DIMENSION);
            width = parseField(widthField,"The length must be at least " + MIN_DIMENSION + ".",MIN_DIMENSION);
            machines.put(Tiles.A, parseField(aField, "The number of A machines needs to be a positive integer.",0));
            machines.put(Tiles.B, parseField(bField, "The number of B machines needs to be a positive integer.",0));
            machines.put(Tiles.C, parseField(cField, "The number of C machines needs to be a positive integer.",0));
            machines.put(Tiles.D, parseField(dField, "The number of D machines needs to be a positive integer.",0));
            machines.put(Tiles.E, parseField(eField, "The number of E machines needs to be a positive integer.",0));
            exchanges = parseField(exchangeField, "The number of exchanges needs to be a positive integer.",0);
            generations = parseField(generationField, "The number of generations needs to be a positive integer.",0);

            //check for minimum requirements in size
            for (int i : machines.values()) {
                sum += i;
            }
            if (sum < MINIMUM_MACHINES || sum > length * width)
                throw new ArithmeticException();
        }
        catch(ArithmeticException ae){
            error(null, "The total number of machines must be at least " + MINIMUM_MACHINES +
                    ".  And less or equal to the area (" + (length * width) + ").");
            success = false;
        }
        catch(NumberFormatException nfe){
            System.out.println("NFE caught");
            success = false;
        }
        if (success){
            Thread t = new Thread(this::createFactory);
            t.start();

        }
    }

    /**
     *  this method will replace the image currently displayed with the image sent provided the new score is higher
     *  does nothing if the score is lower.  This is a thread safe call.
     * @param i is the image sent to the screen that represents a factory.
     * @param score is the affinity of the factory being represented by the image.
     *
     *
     */
    public void setImage(final Image i,final int score){
        Platform.runLater(()->{
            if (score >= currentHighScore) {
                currentHighScore = score;
                factoryLayout.setImage(i);
                scoreListed.setText("" + currentHighScore);
            }
        });

    }

    /**
     * returns the instance of the controller
     * @return the controller instance
     */
    public static Controller getInstance(){
        return instance;
    }

    /**
     * this method creates the ideal factory via a genetic algorithm.
     */
    private void createFactory()  {

        //disable the button
        buildButton.setDisable(true);

        do {
            currentHighScore = Integer.MIN_VALUE;
            int threads = Runtime.getRuntime().availableProcessors();
            ExecutorService executor = Executors.newFixedThreadPool(threads);
            ArrayList<FactoryBuilder> factoryBuilders = new ArrayList<>();
            //create and run new threads
            for (int i = 0; i < threads; i++) {
                factoryBuilders.add(new FactoryBuilder(length, width, machines, exchanges, generations));
            }
            for (int i = 0; i < threads; i++) {
                executor.execute(factoryBuilders.get(i));
            }

            //stop the threads
            executor.shutdown();
            try {
                executor.awaitTermination(1, TimeUnit.DAYS);
            } catch (InterruptedException ie) {
                System.out.println("Threads interrupted for some reason.");
            }
            System.out.println("Simulation Complete");

            Platform.runLater(()->{
                recent3.setImage(recent2.getImage());
                score3.setText(score2.getText());
                recent2.setImage(recent1.getImage());
                score2.setText(score1.getText());
                recent1.setImage(factoryLayout.getImage());
                score1.setText(scoreListed.getText());
            });

            writeImage();

        }while(continueButton.isSelected());

        System.out.println("Done!");
        buildButton.setDisable(false);
    }

    /**
     * parses a textfield and returns the integer from it.  This throws an NFE exception if something breaks.
     * @param t the textfield that will be parsed
     * @param errorMessage the error message that will displayed as on an error screen if something goes wrong.
     * @param minSize the smallest value that is allowed for the field.
     * @return the parsed field.
     */
    private int parseField(TextField t, String errorMessage, int minSize) {
        int i;
        try{
            i = Integer.parseInt(t.getText());
            if( i < minSize)
                throw new NumberFormatException();
        }
        catch(NumberFormatException nfe){
            error(t,errorMessage);
            throw new NumberFormatException();
        }
        return i;
    }

    /**
     * this displays the error message if improper info is entered.
     * @param focus the TextField that is incorrect and needs to be focuses on.
     * @param message the error message.
     */
    private void error(final TextField focus,final String message){
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setHeaderText("Error");
        alert.setContentText(message);
        alert.showAndWait();
        if(focus != null){
            focus.requestFocus();
        }
    }

    /**
     * this method writes the final image to the local directory and saves it.
     */
    private void writeImage(){
        try{
            Image i = factoryLayout.getImage();
            //String s = new File(Controller.class.getProtectionDomain().getCodeSource().getLocation().toURI()).getPath();
            File f = new File(   File.separator + "Finished Factory " + finishedFactories + ".png");
            System.out.println(f.toPath().toString());

            ImageIO.write(SwingFXUtils.fromFXImage(i,null),"png",f);
            System.out.println(f.getAbsolutePath());
        } catch (IOException e) {
            System.out.println("Image Write Failed");
            finishedFactories--;
        }
        finishedFactories++;
    }
}